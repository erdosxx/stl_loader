<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Medit STL loader</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

    </style>
</head>
<body>

<script type="text/javascript" src="js/three.min.js"></script>
<script type="text/javascript" src="js/three.js"></script>

<script type="text/javascript" src="js/libs/stats.min.js"></script>
<script type="text/javascript" src="js/Detector.js"></script>

<script type="text/javascript" src="js/loaders/STLLoader.js"></script>
<script type="text/javascript" src="js/loaders/draco_decoder.js"></script>
<script type="text/javascript" src="js/loaders/DRACOLoader.js"></script>
<script type="text/javascript" src="js/loaders/ctm/lzma.js"></script>
<script type="text/javascript" src="js/loaders/ctm/ctm.js"></script>
<script type="text/javascript" src="js/loaders/ctm/CTMLoader.js"></script>

<script type="text/javascript" src="js/OrthographicTrackballControls_medit.js"></script>

<script>
    // Draco code is not comparable with IE 10. (let, const keywords are not support!)
    if ( ! Detector.webgl ) {
        Detector.addGetWebGLMessage();
    }

    var renderer = new THREE.WebGLRenderer({antialias: true});
    var scene = new THREE.Scene();
    var camera, light, controls, mesh;

    var raycaster = new THREE.Raycaster();
    var faceNormalHelper;

    var isFileLoaded = false;

    var stats, container;

    // Module that exposes all the core funcionality of the Draco decoder.
    const DracoModule = Module;

    var stlFiles = [
        './models/stl/binary/2011-02-09_00001-001-36-35-34-33-32-31-41-42-43-44-45-46-bitesplint_cad.stl',
        './models/stl/binary/2011-02-09_00001-001-lowerjaw.stl',
        './models/stl/binary/2011-02-09_00001-001-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-007-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-11-abutment_cad.stl',
        './models/stl/binary/2011-02-11_00001-010-lowerjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw-gingiva.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw-marker.stl',
        './models/stl/binary/2011-02-11_00001-011.stl',
        './models/stl/binary/2011-02-14_00001-001.stl',
        './models/stl/binary/EsteDent_Model_1.stl'
    ];

    var drcFiles = [
        './models/drc/2011-02-09_00001-001-36-35-34-33-32-31-41-42-43-44-45-46-bitesplint_cad.drc',
        './models/drc/2011-02-09_00001-001-lowerjaw.drc',
        './models/drc/2011-02-09_00001-001-upperjaw.drc',
        './models/drc/2011-02-11_00001-007-upperjaw.drc',
        './models/drc/2011-02-11_00001-010-11-abutment_cad.drc',
        './models/drc/2011-02-11_00001-010-lowerjaw.drc',
        './models/drc/2011-02-11_00001-010-upperjaw.drc',
        './models/drc/2011-02-11_00001-010-upperjaw-gingiva.drc',
        './models/drc/2011-02-11_00001-010-upperjaw-marker.drc',
        './models/drc/2011-02-11_00001-011.drc',
        './models/drc/2011-02-14_00001-001.drc',
        './models/drc/EsteDent_Model_1.drc'
    ];

    var ctmFiles = [
        './models/ctm/2011-02-09_00001-001-36-35-34-33-32-31-41-42-43-44-45-46-bitesplint_cad.ctm',
        './models/ctm/2011-02-09_00001-001-lowerjaw.ctm',
        './models/ctm/2011-02-09_00001-001-upperjaw.ctm',
        './models/ctm/2011-02-11_00001-007-upperjaw.ctm',
        './models/ctm/2011-02-11_00001-010-11-abutment_cad.ctm',
        './models/ctm/2011-02-11_00001-010-lowerjaw.ctm',
        './models/ctm/2011-02-11_00001-010-upperjaw.ctm',
        './models/ctm/2011-02-11_00001-010-upperjaw-gingiva.ctm',
        './models/ctm/2011-02-11_00001-010-upperjaw-marker.ctm',
        './models/ctm/2011-02-11_00001-011.ctm',
        './models/ctm/2011-02-14_00001-001.ctm',
        './models/ctm/EsteDent_Model_1.ctm'
    ];

    init();
    animate();

    function init() {
        defineRenderer();

        defineCamera();

        //createStlObject(stlFiles[2]);
        createCtmObject(ctmFiles[2]);
        //createDrcObject(drcFiles[2]);

        addFaceNormalHelper();

        addAxisHelper();

        createPointLight(camera);

        defineOrthographicTrackballControls();

        addFrameStatisticsInfo();

        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('touchend', onMouseMove, false);

    }

    function addFrameStatisticsInfo() {
        stats = new Stats();
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        container.appendChild( stats.dom );
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        stats.begin();
        render();
        stats.end();
    }

    function defineRenderer() {
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        var backgroundColor = 0x323232;
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setClearColor(backgroundColor, 1);
        document.body.appendChild(renderer.domElement);
    }

    function defineCamera() {
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        camera = new THREE.OrthographicCamera(WIDTH / -25, WIDTH / 25, HEIGHT / 25, HEIGHT / -25, 1, 1000);
    }

    function createStlObject(stlFile) {
        var stlLoader = new THREE.STLLoader();

        stlLoader.load(stlFile, setObject);

        function setObject(geometry) {
            var material = new THREE.MeshPhongMaterial({color: 0xFFEFCC, specular: 0x111111,
                shininess: 200, side: THREE.DoubleSide});
            mesh = new THREE.Mesh(geometry, material);

            var boundingboxProperty = {
                center: new THREE.Vector3(),
                width: 0,
                height: 0,
                depth: 0
            };

            computeBoundingboxProperty(geometry, boundingboxProperty);

            moveMeshToCenter(boundingboxProperty);

            setCameraPosition(boundingboxProperty);

            scene.add(mesh);

            isFileLoaded = true;
        }
    }

    function createCtmObject(ctmFile) {
        var ctmLoader = new THREE.CTMLoader();

        ctmLoader.load(ctmFile, setObject);

        function setObject(geometry) {
            var material = new THREE.MeshPhongMaterial({color: 0xFFEFCC, specular: 0x111111,
                shininess: 200, shading: THREE.FlatShading, side: THREE.DoubleSide});
            mesh = new THREE.Mesh(geometry, material);

            var boundingboxProperty = {
                center: new THREE.Vector3(),
                width: 0,
                height: 0,
                depth: 0
            };

            computeBoundingboxProperty(geometry, boundingboxProperty);

            moveMeshToCenter(boundingboxProperty);

            setCameraPosition(boundingboxProperty);

            scene.add(mesh);

            isFileLoaded = true;
        }
    }

    function createDrcObject(drcFile) {
        var drcLoader = new THREE.FileLoader();
        drcLoader.setResponseType( 'arraybuffer' );
        drcLoader.load(drcFile, drcOnload);

        function drcOnload(data) {
            var dracoLoader = new THREE.DRACOLoader();
            var geometry = dracoLoader.decodeDracoFile(data);

            var material = new THREE.MeshPhongMaterial({color: 0xFFEFCC, specular: 0x111111,
                shininess: 200, shading: THREE.FlatShading, side: THREE.DoubleSide});
            geometry.computeVertexNormals();
            mesh = new THREE.Mesh(geometry, material);

            var boundingboxProperty = {
                center: new THREE.Vector3(),
                width: 0,
                height: 0,
                depth: 0
            };

            computeBoundingboxProperty(geometry, boundingboxProperty);

            moveMeshToCenter(boundingboxProperty);

            setCameraPosition(boundingboxProperty);

            scene.add(mesh);

            isFileLoaded = true;
        }
    }

    function computeBoundingboxProperty(geometry, boundingboxProperty) {
        geometry.computeBoundingBox();  // otherwise geometry.boundingBox will be undefined

        var boundingBox = new THREE.Box3();
        boundingBox = geometry.boundingBox.clone();

        var minVertex = new THREE.Vector3(boundingBox.min.x, boundingBox.min.y, boundingBox.min.z);
        var maxVertex = new THREE.Vector3(boundingBox.max.x, boundingBox.max.y, boundingBox.max.z);

        boundingboxProperty.center.set(
            (maxVertex.x + minVertex.x) / 2,
            (maxVertex.y + minVertex.y) / 2,
            (maxVertex.z + minVertex.z) / 2
        );

        boundingboxProperty.width = maxVertex.x - minVertex.x;
        boundingboxProperty.height = maxVertex.y - minVertex.y;
        boundingboxProperty.depth = maxVertex.z - minVertex.z;
    }

    function moveMeshToCenter(boundingboxProperty) {
        mesh.position.sub(boundingboxProperty.center);
    }

    function setCameraPosition(boundingboxProperty) {
        var fieldOfView = 70;
        var fov = fieldOfView * ( Math.PI / 180 );

        var objectSize = Math.max(boundingboxProperty.height, boundingboxProperty.width);

        var cameraLocation = boundingboxProperty.depth / 2 + Math.abs(objectSize / (2 * Math.tan(fov / 2)));
        var fixedCameraPosition = cameraLocation;

        camera.position.set(0, 0, fixedCameraPosition);

        scene.add(camera);
    }

    function addFaceNormalHelper() {
        var geometry = new THREE.CylinderGeometry(0, 0.5, 3, 12);

        geometry.rotateX(Math.PI / 2);
        faceNormalHelper = new THREE.Mesh(geometry, new THREE.MeshNormalMaterial());
        scene.add(faceNormalHelper);
    }

    function addAxisHelper() {
        var axisHelper = new THREE.AxisHelper(10);
        scene.add(axisHelper);
    }

    function createPointLight(camera) {
        light = new THREE.PointLight(0xffffff, 1, 200);

        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        scene.add(light);
    }

    function defineOrthographicTrackballControls() {
        controls = new THREE.OrthographicTrackballControls(camera);
        controls.rotateSpeed = 2;
        controls.panSpeed = 0.8;
        controls.zoomSpeed = 1.7;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [65, 83, 68];
        controls.addEventListener('change', render);
    }

    function onMouseMove(event) {
        var centerOfScreen = new THREE.Vector2();

        // set raycaster to center of screen
        raycaster.setFromCamera(centerOfScreen, camera);
        var intersects;

        if (isFileLoaded) {
            // See if the ray from the camera into the world hits one of our meshes
            intersects = raycaster.intersectObject(mesh);

            if (isIntersect()) {
                updateFaceNormalHelper();
                moveOriginToCenterOfScreenAtFaceNormal();
            } else {
                restoreFaceNormalPointToOrigin();
            }
        }

        function moveOriginToCenterOfScreenAtFaceNormal () {
            mesh.geometry.translate(- intersects[0].point.x, - intersects[0].point.y, - intersects[0].point.z);
        }

        function isIntersect() {
            return intersects.length > 0;
        }

        function updateFaceNormalHelper() {
            faceNormalHelper.lookAt(intersects[0].face.normal);
            faceNormalHelper.position.copy(intersects[0].point);
        }

        function restoreFaceNormalPointToOrigin() {
            var normalDirection = new THREE.Vector3(0, 0, 1);
            faceNormalHelper.position.set(0, 0, 0);
            faceNormalHelper.lookAt(normalDirection);
        }
    }

    function render() {
        light.position.copy(camera.position);
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        renderer.setSize(WIDTH, HEIGHT);

        camera.aspect = WIDTH / HEIGHT;
        camera.left = WIDTH / -25;
        camera.right = WIDTH / 25;
        camera.top = HEIGHT / 25;
        camera.bottom = HEIGHT / -25;

        camera.updateProjectionMatrix();
        controls.handleResize();
    }

</script>

</body>
</html>
