<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Medit STL loader</title>
    <style>
        body
        {
            margin: 0;
        }
        canvas
        {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script type="text/javascript" src="js/three.min.js"> </script>
<script type="text/javascript" src="js/loaders/STLLoader.js"> </script>
<script type="text/javascript" src="js/OrbitControls.js"></script>
<script type="text/javascript" src="js/TrackballControls.js"></script>
<script type="text/javascript" src="js/OrthographicTrackballControls_erdos.js"></script>

<script>
    let renderer = new THREE.WebGLRenderer({antialias:true});
    let scene = new THREE.Scene();
    let field_of_view = 70;
    //let camera = new THREE.PerspectiveCamera(field_of_view, WIDTH/HEIGHT);
    let camera;
    let light;
    let controls;
    let mesh;

    let raycaster = new THREE.Raycaster();
    let fn_helper;

    let stl_files = [
        './models/stl/binary/2011-02-09_00001-001-36-35-34-33-32-31-41-42-43-44-45-46-bitesplint_cad.stl',
        './models/stl/binary/2011-02-09_00001-001-lowerjaw.stl',
        './models/stl/binary/2011-02-09_00001-001-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-007-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-11-abutment_cad.stl',
        './models/stl/binary/2011-02-11_00001-010-lowerjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw-gingiva.stl',
        './models/stl/binary/2011-02-11_00001-010-upperjaw-marker.stl',
        './models/stl/binary/2011-02-11_00001-011.stl',
        './models/stl/binary/2011-02-14_00001-001.stl'
    ];

    init();
    animate();

    function add_face_normal_helper() {
        let geometry = new THREE.CylinderGeometry( 0, 0.5, 3, 12 );

        //geometry.translate( 0, 50, 0 );
        geometry.rotateX( Math.PI / 2 );
        fn_helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
        scene.add( fn_helper );
    }

    function onMouseMove(event) {
        let mouse = new THREE.Vector2();
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

        raycaster.setFromCamera( mouse, camera );

        // See if the ray from the camera into the world hits one of our meshes
        let intersects = raycaster.intersectObject( mesh );


        // Toggle rotation bool for meshes that we clicked
        if ( intersects.length > 0 ) {
            fn_helper.position.set( 0, 0, 0 );
            fn_helper.lookAt( intersects[ 0 ].face.normal );
            fn_helper.position.copy( intersects[ 0 ].point );
            console.log("Insersect x: " + intersects[0].point.x);
            console.log("Insersect y: " + intersects[0].point.y);
            console.log("Insersect z: " + intersects[0].point.z);
//            console.log("helper x: " + helper.position.x);
//            console.log("helper y: " + helper.position.y);
//            console.log("helper z: " + helper.position.z);
            //console.log("Intersects!");
        } else {
            let normal_direction = new THREE.Vector3(0,0,1);
            fn_helper.position.set( 0, 0, 0 );
            fn_helper.lookAt(normal_direction);
            console.log("Not Intersects!");
        }
    }

    function init() {
        define_renderer();

        define_camera();

        create_stl_object(stl_files[1]);

        add_face_normal_helper();

        add_axis_helper();

        //add_arrow_helper(1.8, -46.3, 4.4);
        //add_arrow_helper(63.8, 3.6, 25.5);

        //add_gridHelper();

//        create_light_up();
//        create_light_down();
//        create_ambientlight();
//        create_hemisphereLight();
        //create_SpotLight();
        create_pointLight(camera);

        //define_camera();

        //define_orbit_controls();
        //define_trackball_controls();
        define_orthographic_trackball_controls();

        window.addEventListener('resize', onWindowResize);
        window.addEventListener( 'mousemove', onMouseMove, false );
    }

    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        render();
    }

    function define_camera() {
        let WIDTH = window.innerWidth;
        let HEIGHT = window.innerHeight;
        //let camera = new THREE.PerspectiveCamera(field_of_view, WIDTH/HEIGHT);
        camera = new THREE.OrthographicCamera(WIDTH/-25, WIDTH/25, HEIGHT/25, HEIGHT/-25, 1, 1000);
    }


    function render() {
        //light.position.set(camera.position.x, camera.position.y, camera.position.z);
        light.position.copy(camera.position);
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        let width = window.innerWidth;
        let height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        controls.handleResize();
    }

    function define_renderer() {
        let width = window.innerWidth;
        let height = window.innerHeight;
        renderer.setSize(width, height);
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);
    }

    function add_axis_helper() {
        var axisHelper = new THREE.AxisHelper( 100 );
        scene.add( axisHelper );
    }

    function add_camera_helper() {
        var helper = new THREE.CameraHelper( camera );
        scene.add( helper );
    }

    function add_gridHelper() {
        var size = 100;
        var divisions = 10;

        var gridHelper = new THREE.GridHelper( size, divisions );
        scene.add( gridHelper );
    }

    function add_arrow_helper(x,y,z) {
        var dir = new THREE.Vector3( x, y, z );

        var vec_size = dir.size;

//normalize the direction vector (convert to vector of length 1)
        dir.normalize();

        var origin = new THREE.Vector3( 0, 0, 0 );
        var length = 1;
        var hex = 0xff9933;

        var arrowHelper = new THREE.ArrowHelper( dir, origin, 65, hex );
        scene.add( arrowHelper );
    }

    function check_invert_object(filename ) {
        let pattern = new RegExp("[U|u]pper");
        let res = pattern.test(filename);
        if (res) {
            console.log("pattern found!");
        } else {
            console.log("pattern Not found!");
        }
        return res;
    }


    function create_stl_object(stl_file) {
        let stl_loader = new THREE.STLLoader();

        stl_loader.load(stl_file, set_object);

        function set_object(geometry) {
            let material = new THREE.MeshPhongMaterial({color: 0xFFEFCC, specular: 0x111111, shininess: 200});
            mesh = new THREE.Mesh( geometry, material );

            add_object_boundingbox_to_scene();

            let boundingbox_property = {
                center: new THREE.Vector3(),
                width: 0,
                height: 0,
                depth: 0
            };

            compute_boundingbox_property(geometry, boundingbox_property);

            move_mesh_to_center(boundingbox_property);

            //let isInvert = check_invert_object(stl_file);
            //set_camera_location(boundingbox_property, isInvert);
            set_camera_position(boundingbox_property);
            //create_pointLight(camera);

            scene.add( mesh );
        }
    }

    function move_mesh_to_center(boundingbox_property) {
        mesh.position.sub(boundingbox_property.center);
    }

    function compute_boundingbox_property(geometry, boundingbox_property) {
        geometry.computeBoundingBox();  // otherwise geometry.boundingBox will be undefined

        let boundingBox = new THREE.Box3();
        boundingBox = geometry.boundingBox.clone();

        let min_vertex = new THREE.Vector3(boundingBox.min.x, boundingBox.min.y, boundingBox.min.z);
        let max_vertex = new THREE.Vector3(boundingBox.max.x, boundingBox.max.y, boundingBox.max.z);

        boundingbox_property.center.set(
            (max_vertex.x + min_vertex.x) / 2,
            (max_vertex.y + min_vertex.y) / 2,
            (max_vertex.z + min_vertex.z) / 2
        );

        console.log('bounding box coordinates: ' +
            '(' + min_vertex.x + ', ' + min_vertex.y + ', ' + min_vertex.z + '), ' +
            '(' + max_vertex.x + ', ' + max_vertex.y + ', ' + max_vertex.z + ')');

        boundingbox_property.width =  max_vertex.x - min_vertex.x;
        boundingbox_property.height = max_vertex.y - min_vertex.y;
        boundingbox_property.depth = max_vertex.z - min_vertex.z;
    }

    function set_camera_position(boundingbox_property, isInvert = false) {
        let fov = field_of_view * ( Math.PI / 180 );

        let objectSize = Math.max(boundingbox_property.height, boundingbox_property.width);

        let camera_loc = boundingbox_property.depth/2 + Math.abs( objectSize / (2 * Math.tan( fov / 2 )) );
        let fixed_camera_position = isInvert ?  -1 * camera_loc : camera_loc;

        camera.position.set(0, 0, fixed_camera_position);

        scene.add(camera);
    }

    function add_object_boundingbox_to_scene() {
        let bbHelper = new THREE.BoxHelper(mesh, 0xffffff);
        bbHelper.visible = true;
        bbHelper.update(mesh);
        scene.add(bbHelper);
    }

    function create_ambientlight() {
        var light = new THREE.AmbientLight( 0xffffbb, 0.4); // soft white light
        scene.add( light );
    }

    function create_hemisphereLight(isInvert = false) {
        light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1.0 );

        let position = isInvert ? -100: 100;

        light.position.set(0, 0, position);
        //light.position.set(position, position, 0);
        let helper = new THREE.HemisphereLightHelper(light, 100);
        scene.add(helper);
        scene.add(light);
    }

    function create_SpotLight(isInvert = false) {
        light = new THREE.SpotLight( 0xffffbb, 2, 100);

        //camera.add( light.target );
        light.target.position.set(0,0,-1);
        //light.position.set( 0,0,50 ); // and reset spotlight position if camera moves

        let spotLightHelper = new THREE.SpotLightHelper(light);

        scene.add(spotLightHelper);
        scene.add(light);
    }

    function create_pointLight(camera, sInvert = false) {
        light = new THREE.PointLight(0xffffff, 1, 200);

        //light.position.set(0,0,70);
        //light.position = camera.position; // and reset spotlight position if camera moves
        console.log("camera postion x: " + camera.position.x );
        console.log("camera postion y: " + camera.position.y );
        console.log("camera postion z: " + camera.position.z );
        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        let sphereSize = 1;
        var pointLightHelper = new THREE.PointLightHelper(light, sphereSize);
        scene.add(pointLightHelper);
        scene.add(light);
    }

    function create_rectarea_light() {
        let width = 2;
        let height = 10;
        let rectLight = new THREE.RectAreaLight( 0xffffbb, undefined,  width, height );
        rectLight.matrixAutoUpdate = true;
        rectLight.intensity = 70.0;
        rectLight.position.set( 0, 0, 50 );
        rectLightHelper = new THREE.RectAreaLightHelper( rectLight );
        rectLight.add( rectLightHelper );

        scene.add(rectLight)
    }

    function define_orbit_controls() {
        // Add OrbitControls so that we can pan around with the mouse.
         controls = new THREE.OrbitControls(camera, renderer.domElement);
        /*
         var controls = new THREE.TrackballControls( camera );
         controls.rotateSpeed = 1.0;
         controls.zoomSpeed = 1.2;
         controls.panSpeed = 0.8;
         controls.noZoom = false;
         controls.noPan = false;
         controls.staticMoving = true;
         controls.dynamicDampingFactor = 0.3;
         controls.keys = [ 65, 83, 68 ];
         controls.addEventListener( 'change', render );
         */
    }

    function define_trackball_controls() {
        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );
    }

    function define_orthographic_trackball_controls() {
        controls = new THREE.OrthographicTrackballControls( camera );
        controls.rotateSpeed = 2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;
        controls.keys = [ 65, 83, 68 ];
        controls.addEventListener( 'change', render );
    }

</script>

</body>
</html>